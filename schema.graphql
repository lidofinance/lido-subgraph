"""
Lido
"""
type LidoConfig @entity {
  id: ID!

  insuranceFund: Bytes
  oracle: Bytes
  treasury: Bytes

  isStopped: Boolean!
  isStakingPaused: Boolean!

  maxStakeLimit: BigInt!
  stakeLimitIncreasePerBlock: BigInt!

  elRewardsVault: Bytes
  elRewardsWithdrawalLimitPoints: BigInt!

  withdrawalCredentials: Bytes!
  wcSetBy: Bytes
  lidoLocator: Bytes

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type LidoTransfer @entity(immutable: true) {
  id: Bytes!

  from: Bytes!
  to: Bytes!
  value: BigInt!

  shares: BigInt!
  sharesBeforeDecrease: BigInt
  sharesAfterDecrease: BigInt
  sharesBeforeIncrease: BigInt
  sharesAfterIncrease: BigInt

  mintWithoutSubmission: Boolean

  totalPooledEther: BigInt!
  totalShares: BigInt!

  balanceAfterDecrease: BigInt
  balanceAfterIncrease: BigInt

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type LidoApproval @entity(immutable: true) {
  id: Bytes!

  owner: Bytes!
  spender: Bytes!
  value: BigInt!
}

# type LidoWithdrawalCredential @entity(immutable: true) {
#   id: Bytes!

#   withdrawalCredentials: Bytes!
#   setBy: Bytes

#   block: BigInt!
#   blockTime: BigInt!
#   transactionHash: Bytes!
#   logIndex: BigInt!
# }

type LidoSubmission @entity(immutable: true) {
  id: Bytes!

  sender: Bytes!
  amount: BigInt!
  referral: Bytes!

  shares: BigInt!
  sharesBefore: BigInt!
  sharesAfter: BigInt!

  totalPooledEtherBefore: BigInt!
  totalPooledEtherAfter: BigInt!
  totalSharesBefore: BigInt!
  totalSharesAfter: BigInt!

  balanceAfter: BigInt!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type NodeOperatorFees @entity(immutable: true) {
  id: Bytes!
  totalReward: TotalReward!

  address: Bytes!
  fee: BigInt!
}

type NodeOperatorsShares @entity(immutable: true) {
  id: Bytes!
  totalReward: TotalReward!

  address: Bytes!
  shares: BigInt!
}

type Total @entity {
  id: ID!

  totalPooledEther: BigInt!
  totalShares: BigInt!
}

type Stat @entity {
  id: ID!

  uniqueHolders: BigInt!
  uniqueAnytimeHolders: BigInt!
  lastOracleCompletedId: BigInt!
}

type Share @entity {
  id: Bytes!

  shares: BigInt!
}

type Holder @entity {
  id: Bytes!

  address: Bytes!
  hasBalance: Boolean!
}

type CurrentFee @entity {
  id: ID!

  feeBasisPoints: BigInt!
  treasuryFeeBasisPoints: BigInt!
  insuranceFeeBasisPoints: BigInt!
  operatorsFeeBasisPoints: BigInt!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

# type SharesTransfer @entity(immutable: true) {
#   id: ID!

#   from: Bytes!
#   sharesValue: BigInt!
#   to: Bytes!
# }

type SharesBurn @entity(immutable: true) {
  id: Bytes!

  account: Bytes!
  postRebaseTokenAmount: BigInt!
  preRebaseTokenAmount: BigInt!
  sharesAmount: BigInt!
}

"""
LegacyOracle
"""
type OracleCompleted @entity(immutable: true) {
  id: ID!

  epochId: BigInt!
  beaconBalance: BigInt!
  beaconValidators: BigInt!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

"""
Main entity for daily rewards
"""
type TotalReward @entity {
  "transactionHash"
  id: Bytes!

  "Total user rewards"
  totalRewards: BigInt!
  "Total user rewards + fees"
  totalRewardsWithFees: BigInt!

  "Fees received via validator MEV"
  mevFee: BigInt!

  "Fee basis points eg fractions of total fees"
  feeBasis: BigInt!
  treasuryFeeBasisPoints: BigInt!
  insuranceFeeBasisPoints: BigInt!
  operatorsFeeBasisPoints: BigInt!

  "Fees and leftover dust after rounding"
  totalFee: BigInt!
  nodeOperatorFees: [NodeOperatorFees!] @derivedFrom(field: "totalReward")
  insuranceFee: BigInt!
  operatorsFee: BigInt!
  treasuryFee: BigInt!
  dust: BigInt!

  "Total shares that were minted for distribution"
  shares2mint: BigInt!

  "Shares distributed to each destination"
  sharesToTreasury: BigInt!
  sharesToInsuranceFund: BigInt!
  sharesToOperators: BigInt!
  nodeOperatorsShares: [NodeOperatorsShares!] @derivedFrom(field: "totalReward")
  dustSharesToTreasury: BigInt!

  "State of the pool before and after rewards"
  totalPooledEtherBefore: BigInt!
  totalPooledEtherAfter: BigInt!
  totalSharesBefore: BigInt!
  totalSharesAfter: BigInt!

  "Data for easy APR calculations"
  # postTotalPooledEther: BigInt
  # preTotalPooledEther: BigInt
  timeElapsed: BigInt!
  # totalShares: BigInt

  "Raw APR from validator balances"
  aprRaw: BigDecimal!
  "Time-compensated APR eg account for a missed day of rewards between reports"
  aprBeforeFees: BigDecimal!
  "User APR after fees and time correction"
  apr: BigDecimal!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type OracleMember @entity {
  id: Bytes!

  member: Bytes!
  removed: Boolean!
}

# type OracleQuorumChange @entity(immutable: true) {
#   id: ID!

#   quorum: BigInt!
# }

# type OracleVersion @entity(immutable: true) {
#   id: ID!

#   version: BigInt!

#   block: BigInt!
#   blockTime: BigInt!
# }

# type AllowedBeaconBalanceRelativeDecrease @entity(immutable: true) {
#   id: ID!

#   value: BigInt!
# }

# type AllowedBeaconBalanceAnnualRelativeIncrease @entity(immutable: true) {
#   id: ID!

#   value: BigInt!
# }

# type OracleExpectedEpoch @entity(immutable: true) {
#   id: ID!

#   epochId: BigInt!
# }

# type BeaconReport @entity(immutable: true) {
#   id: ID!

#   epochId: BigInt!
#   beaconBalance: BigInt!
#   beaconValidators: BigInt!
#   caller: Bytes!
# }

# type BeaconSpec @entity(immutable: true) {
#   id: ID!

#   epochsPerFrame: BigInt!
#   slotsPerEpoch: BigInt!
#   secondsPerSlot: BigInt!
#   genesisTime: BigInt!
# }

# type BeaconReportReceiver @entity(immutable: true) {
#   id: ID!

#   callback: Bytes!
# }

# """
# NodeOperatorsRegistry
# """
# type NodeOperatorSigningKey @entity {
#   id: Bytes!

#   operatorId: BigInt!
#   pubkey: Bytes!
#   removed: Boolean!

#   operator: NodeOperator!
# }

# type NodeOperator @entity {
#   id: ID!

#   name: String!
#   rewardAddress: Bytes!
#   stakingLimit: BigInt!
#   active: Boolean!
#   totalStoppedValidators: BigInt
#   # nonce: BigInt!
# }

# type NodeOperatorTotalKeysTrim @entity(immutable: true) {
#   id: ID!

#   operatorId: BigInt!
#   totalKeysTrimmed: BigInt!

#   operator: NodeOperator!

#   block: BigInt!
#   blockTime: BigInt!
# }

# type handleKeysOpIndexChange @entity {
#   id: ID!

#   index: BigInt!

#   block: BigInt!
#   blockTime: BigInt!
# }

# """
# Voting
# """
# type Voting @entity {
#   id: ID!

#   index: Int!
#   creator: Bytes!
#   metadata: String!
#   executed: Boolean!

#   votes: [Vote!]! @derivedFrom(field: "voting")
#   objections: [VotingObjection!]! @derivedFrom(field: "voting")
# }

# type Vote @entity(immutable: true) {
#   id: ID!

#   voting: Voting!
#   voter: Bytes!
#   supports: Boolean!
#   stake: BigInt!
# }

# type VotingObjection @entity(immutable: true) {
#   id: ID!

#   voting: Voting!
#   voter: Bytes!
#   stake: BigInt!
# }

# type ChangedSupportRequired @entity(immutable: true) {
#   id: ID!

#   supportRequiredPct: BigInt!
# }

# type ChangedMinQuorum @entity(immutable: true) {
#   id: ID!

#   minAcceptQuorumPct: BigInt!
# }

# type ChangedVoteTime @entity(immutable: true) {
#   id: ID!

#   voteTime: BigInt!
# }

# type ChangedObjectionPhaseTime @entity(immutable: true) {
#   id: ID!

#   objectionPhaseTime: BigInt!
# }

"""
EasyTrack
"""
type Motion @entity {
  id: ID!

  creator: Bytes!
  evmScriptFactory: Bytes!
  duration: BigInt
  startDate: BigInt!
  snapshotBlock: BigInt!
  objectionsAmount: BigInt!
  objectionsAmountPct: BigInt!
  objectionsThreshold: BigInt
  evmScriptHash: Bytes!
  evmScriptCalldata: Bytes!
  status: String!
  enacted_at: BigInt
  canceled_at: BigInt
  rejected_at: BigInt

  objections: [Objection!] @derivedFrom(field: "motion")

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type EasyTrackConfig @entity {
  id: ID!

  evmScriptExecutor: Bytes!
  motionDuration: BigInt!
  motionsCountLimit: BigInt!
  objectionsThreshold: BigInt!
  isPaused: Boolean!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type Role @entity {
  id: Bytes!

  role: Bytes!
  address: Bytes!
  creator: Bytes!
  isActive: Boolean!
}

type EVMScriptFactory @entity {
  id: Bytes!

  address: Bytes!
  permissions: Bytes!
  isActive: Boolean!
}

type Objection @entity(immutable: true) {
  id: Bytes!

  motionId: BigInt!
  objector: Bytes!
  weight: BigInt!

  motion: Motion!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

# """
# DepositSecurityModule
# """
# type DepositSecurityModuleSettings @entity {
#   id: ID!

#   paused: Boolean
#   guardianQuorum: BigInt
#   maxDeposits: BigInt
#   minDepositBlockDistance: BigInt
#   nodeOperatorsRegistry: Bytes
#   owner: Bytes
#   pauseIntentValidityPeriodBlocks: BigInt
# }

# type DepositsPause @entity(immutable: true) {
#   id: ID!

#   guardian: Guardian!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type DepositsUnpause @entity(immutable: true) {
#   id: ID!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type Guardian @entity {
#   id: ID!

#   address: Bytes!
#   removed: Boolean!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type GuardianQuorumChange @entity(immutable: true) {
#   id: ID!

#   guardianQuorum: BigInt!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type MaxDepositsChange @entity(immutable: true) {
#   id: ID!

#   maxDeposits: BigInt!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type MinDepositBlockDistanceChange @entity(immutable: true) {
#   id: ID!

#   minDepositBlockDistance: BigInt!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type NodeOperatorsRegistryChange @entity(immutable: true) {
#   id: ID!

#   nodeOperatorsRegistry: Bytes!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type OwnerChange @entity(immutable: true) {
#   id: ID!

#   owner: Bytes!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type PauseIntentValidityPeriodBlocksChange @entity(immutable: true) {
#   id: ID!

#   pauseIntentValidityPeriodBlocks: BigInt!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

type OracleReport @entity {
  "v2 oracle report refSlot = ID"
  id: ID!

  totalReward: TotalReward!

  hash: Bytes!

  itemsProcessed: BigInt!
  itemsCount: BigInt!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

"""
Lido DAO
"""
type AppVersion @entity {
  id: Bytes!
  major: Int!
  minor: Int!
  patch: Int!
  impl: Bytes!

  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

# WithdrawalQueue

# type BunkerModeDisabled @entity(immutable: true) {
#   id: Bytes!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type BunkerModeEnabled @entity(immutable: true) {
#   id: Bytes!
#   _sinceTimestamp: BigInt! # uint256
# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type ContractVersionSet @entity(immutable: true) {
#   id: Bytes!
#   version: BigInt! # uint256
# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type Paused @entity(immutable: true) {
#   id: Bytes!
#   duration: BigInt! # uint256
# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

# type Resumed @entity(immutable: true) {
#   id: Bytes!

# block: BigInt!
# blockTime: BigInt!
# transactionHash: Bytes!
# logIndex: BigInt!
# }

type WithdrawalClaimed @entity(immutable: true) {
  id: Bytes!
  requestId: BigInt! # uint256
  owner: Bytes! # address
  receiver: Bytes! # address
  amountOfETH: BigInt! # uint256
  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type WithdrawalRequested @entity(immutable: true) {
  id: Bytes!
  requestId: BigInt! # uint256
  requestor: Bytes! # address
  owner: Bytes! # address
  amountOfStETH: BigInt! # uint256
  amountOfShares: BigInt! # uint256
  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}

type WithdrawalsFinalized @entity(immutable: true) {
  id: Bytes!
  from: BigInt! # uint256
  to: BigInt! # uint256
  amountOfETHLocked: BigInt! # uint256
  sharesToBurn: BigInt! # uint256
  timestamp: BigInt! # uint256
  block: BigInt!
  blockTime: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
}
